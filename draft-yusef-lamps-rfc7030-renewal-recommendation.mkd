---
title: Certificate Renewal Recommendations for Enrollment over Secure Transport
abbrev: est-renew
docname: draft-yusef-lamps-rfc7030-renewal-recommendation-00

# stand_alone: true

ipr: trust200902
area: Internet
wg: LAMPS Working Group
kw: Internet-Draft
cat: std

coding: utf-8
pi:    # can use array (if all yes) or hash here
  toc: yes
  sortrefs:   # defaults to yes
  symrefs: yes

author:
- ins: R. Shekh-Yusef
  name: Rifaat Shekh-Yusef
  org: Ciena
  email: rifaat.s.ietf@gmail.com

- ins: M. Richardson
  name: Michael Richardson
  org: Sandelman Software Works
  email: mcr+ietf@sandelman.ca

normative:
  RFC7030:

informative:
  RFC9773:

venue:
  group: lamps
  mail: spasm@ietf.org
  github: mcr/rfc7030-renewal-recommendation

--- abstract

This document describes an extension to RFC7030, Enrollment over Secure Transport to
give an indication to a end-entity device when it should start attempting to renew its certificates.

Prior art is that client decides, with a typical recommmendation to start when the remaining lifetime of the certificate is at the 50% point.
As typical certificate lifetimes are reduced from years to fractions of a year, the 50% may be far too early, and this document provides a way to give alternate advice.

--- middle

# Introduction

{{RFC9773, Section 1}} explains why certificate lifetimes and renewal times need more deterministic control in the ACME {{?RFC8555}} ecosystem.
Similar arguments apply to the {{RFC7030}} ecosystem.

(Do the ecosystems differ in significant ways?  Probably. How much to explain)

Is this as much about client certificates and IoT certificates?

# Terminology

{::boilerplate bcp14-tagged}

# Protocol Details

A new magic header will be returned during RFC7030 certificate enrollment, whether using simpleenroll, or fullcmc.

# Renewal Information Request

To retrieve the renewal information, the EST client uses the following HTTP request-line:

```
GET /.well-known/est/renewal-info/<certificate-id>
```

The request includes a unique identifier for the certificate in question. The unique identifier is constructed by concatenating the base64url encoding [RFC4648] of the keyIdentifier field of the certificate's Authority Key Identifier (AKI) [RFC5280] extension, the period character ".", and the base64url encoding of the DER-encoded Serial Number field (without the tag and length bytes).  All trailing "=" characters MUST be stripped from both parts of the unique identifier.

Thus, the full request URL is constructed as follows (split onto multiple lines for readability), where the "||" operator indicates string concatenation:

```
url = /.well-known/est/renewal-info
      || '/'
      || base64url(AKI keyIdentifier)
      || '.'
      || base64url(Serial)
```


Question
Should we also support an operation that is not certificate specific, to provide a general renewal info, in the absence of a certificate renewal info.

GET /.well-known/est/renew-info

# Renewal Information Response

The structure the EST RenewalInfo object is as follows:

suggestedWindow (object, required):
      A JSON object with two keys, "start" and "end", whose values are
      timestamps, encoded in the format specified in {{RFC3339}}, which
      bound the window of time in which the CA recommends renewing the
      certificate.

NOTE: The ACME document includes an explanationURI, which I think is not applicable to this document.

For example:

```
   HTTP/1.1 200 OK
   Content-Type: application/json
   Retry-After: 21600

   {
     "suggestedWindow": {
       "start": "2025-01-02T04:00:00Z",
       "end": "2025-01-03T04:00:00Z"
     }
   }
```

## Base64 Not Used

{{RFC7030}} mistakenly declared that all content would be base64 encoded.
{{RFC8951}} clarifies that the content is to be base64 encoded, whether or not there is a Content-Transfer-Encoding header present.
It further clarifies that future extensions (such as this document) will not use base64 encoding.
The response detailed above is not base64 encoded.

# Renewal Operations

Clients MUST attempt renewal at a time of their choosing based on the suggested renewal window, obtained in the previous step.

The following algorithm is RECOMMENDED for choosing a renewal time:

1.  Select a uniform random time within the suggested window.

2.  If the selected time is in the past, attempt renewal immediately.

3.  Otherwise, if the client can schedule itself to attempt renewal
    at exactly the selected time, do so.

4.  Otherwise, if the selected time is before the next time that the
    client would wake up normally, attempt renewal immediately.

5.  Otherwise, sleep until the time indicated by the Retry-After
    header and return to Step 1.

In all cases, renewal attempts are subject to the client's existing error backoff and retry intervals.

   In particular, cron-based clients may find they need to increase their run frequency to
   check ARI more frequently.  Those clients will need to store information about failures
   so that increasing their run frequency doesn't lead to retrying failures without proper
   backoff. Typical information stored should include: number of failures for a given order
   (defined by the set of identifiers on the order) and time of the most recent failure.

`Is the above highlighted text needed???`

A RenewalInfo object in which the end timestamp equals or precedes the start timestamp is invalid.  Servers MUST NOT serve such a response, and clients MUST treat one as though they failed to receive any response from the server (e.g., retry at an appropriate interval, renew on a fallback schedule, etc.).

# Fetching Schedule

{{RFC9773, Section 4.3}} says:


# Privacy Considerations

A very short certificate lifetime renewal time will cause clients to communicate with the EST Registrar more frequently.

EST connections make use of mutually authenticated TLS, when the client certificate being an IDevID, or the last issued certificate, often an LDevID, there is potential to disclose identities during this connection.

When using TLS 1.2, the client certificate details will be revealed.
TLS 1.3 does not suffer from this problem, and it's use is RECOMMENDED as per {{?I-D.ietf-uta-require-tls13}}

# Security Considerations

Not sure what yet.

# IANA Considerations

Might need a header allocation

# Acknowledgements

Hello.

# Changelog


--- back

